<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: a6338d747762e36e01061eae19aadca4167375b6 Maintainer: hirokawa Status: working -->
<!-- CREDITS: shimooka,mumumu -->

<sect1 xml:id="language.oop5.decon" xmlns="http://docbook.org/ns/docbook">
 <title>コンストラクタとデストラクタ</title>

 <sect2 xml:id="language.oop5.decon.constructor">
  <title>コンストラクタ</title>
   <methodsynopsis xml:id="object.construct">
    <type>void</type><methodname>__construct</methodname>
    <methodparam rep="repeat"><type>mixed</type><parameter>values</parameter><initializer>""</initializer></methodparam>
   </methodsynopsis>
  <para>
   PHP では、開発者がクラスのコンストラクタメソッドを宣言することが
   できます。コンストラクタメソッドを有するクラスは、新たにオブジェクトが
   生成される度にこのメソッドをコールします。これにより、
   そのオブジェクトを使用する前に必要な初期化を行うことができます。
  </para>
  <note>
   <simpara>
    子クラスがコンストラクタを有している場合、親クラスのコンストラクタが
    暗黙の内にコールされることはありません。
    親クラスのコンストラクタを実行するには、子クラスのコンストラクタの
    中で <function>parent::__construct</function> をコールすることが
    必要です。
    子クラスでコンストラクタを定義していない場合は、親クラスのコンストラクタを継承します
    (ただし、private 宣言されている場合は除く)。
    これは、通常のクラスメソッドと同様です。
   </simpara>
  </note>
  <example>
   <title>継承とコンストラクタ</title>
   <programlisting role="php">
<![CDATA[
<?php
class BaseClass {
    function __construct() {
        print "In BaseClass constructor\n";
    }
}

class SubClass extends BaseClass {
    function __construct() {
        parent::__construct();
        print "In SubClass constructor\n";
    }
}

class OtherSubClass extends BaseClass {
    // BaseClass のコンストラクタを継承します
}

// In BaseClass constructor
$obj = new BaseClass();

// In BaseClass constructor
// In SubClass constructor
$obj = new SubClass();

// In BaseClass constructor
$obj = new OtherSubClass();
?>
]]>
   </programlisting>
  </example>
   <para>
    他のメソッドと異なり、親の <link linkend="object.construct">__construct()</link>
    と異なるパラメータで <link linkend="object.construct">__construct()</link>
    をオーバーライドしても PHP は
    <constant>E_STRICT</constant> エラーメッセージを出しません。
   </para>
   <para>
    コンストラクタは、対応するオブジェクトを初期化する間に呼び出されるメソッドです。
    よって、任意の数の引数を取ることが出来ます。
    この引数は必須にすることもできますし、型宣言もできますし、デフォルト値を取ったりすることもできます。
    コンストラクタの引数は、クラス名の後の括弧に、引数を置くことで指定することが出来ます。
   </para>
   <example>
    <title>コンストラクタを引数と一緒に使う</title>
    <programlisting role="php">
<![CDATA[
<?php
class Point {
    protected int $x;
    protected int $y;

    public function __construct(int $x, int $y = 0) {
        $this->x = $x;
        $this->y = $y;
    }
}

// 引数を両方渡す
$p1 = new Point(4, 5);
// 必須の引数のみを渡す。$y はデフォルト値0になります。
$p2 = new Point(4);
// 名前付き引数(PHP 8.0 以降):
$p3 = new Point(y: 5, x: 4);
?>
]]>
    </programlisting>
   </example>
   <!-- to be translated -->
   <para>
    If a class has no constructor, or the constructor has no required arguments, the parentheses
    may be omitted.
   </para>
   <sect3>
    <title>Old-style constructors</title>
    <para>
     Prior to PHP 8.0.0, classes in the global namespace will interpret a method named
     the same as the class as an old-style constructor.  That syntax is deprecated,
     and will result in an <constant>E_DEPRECATED</constant> error but still call that function as a constructor.
     If both <link linkend="object.construct">__construct()</link> and a same-name method are
     defined, <link linkend="object.construct">__construct()</link> will be called.
    </para>
    <para>
     In namespaced classes, or any class as of PHP 8.0.0, a method named
     the same as the class never has any special meaning.
    </para>
    <para>Always use <link linkend="object.construct">__construct()</link> in new code.
    </para>
   </sect3>
   <sect3 xml:id="language.oop5.decon.constructor.promotion">
    <title>Constructor Promotion</title>
    <para>
     As of PHP 8.0.0, constructor parameters may also be promoted to correspond to an
     object property.  It is very common for constructor parameters to be assigned to
     a property in the constructor but otherwise not operated upon.  Constructor promotion
     provides a short-hand for that use case.  The example above could be rewritten as the following.
    </para>
    <example>
     <title>Using constructor property promotion</title>
     <programlisting role="php">
<![CDATA[
<?php
class Point {
    public function __construct(protected int $x, protected int $y = 0) {
    }
}
]]>
     </programlisting>
    </example>
    <para>
     When a constructor argument includes a visibility modifier, PHP will interpret it as
     both an object property and a constructor argument, and assign the argument value to
     the property.  The constructor body may then be empty or may contain other statements.
     Any additional statements will be executed after the argument values have been assigned
     to the corresponding properties.
    </para>
    <para>
     Not all arguments need to be promoted. It is possible to mix and match promoted and not-promoted
     arguments, in any order.  Promoted arguments have no impact on code calling the constructor.
    </para>
    <note>
     <para>
      Object properties may not be typed <type>callable</type> due to engine ambiguity that would
      introduce. Promoted arguments, therefore, may not be typed <type>callable</type> either. Any
      other <link linkend="language.types.declarations">type declaration</link> is permitted, however.
     </para>
    </note>
    <note>
     <para>
      <!-- This should be linked once attributes are documented. -->
      Attributes placed on a promoted constructor argument will be replicated to both the property
      and argument.
     </para>
    </note>
   </sect3>
   <sect3 xml:id="language.oop5.decon.constructor.static">
    <title>Static creation methods</title>
    <para>
     PHP only supports a single constructor per class.  In some cases, however, it may be
     desirable to allow an object to be constructed in different ways with different inputs.
     The recommended way to do so is by using static methods as constructor wrappers.
    </para>
    <example>
     <title>Using static creation methods</title>
     <programlisting role="php">
<![CDATA[
<?php
class Product {

    private ?int $id;
    private ?string $name;

    private function __construct(?int $id = null, ?string $name = null) {
        $this->id = $id;
        $this->name = $name;
    }

    public static function fromBasicData(int $id, string $name): static {
        $new = new static($id, $name);
        return $new;
    }

    public static function fromJson(string $json): static {
        $data = json_decode($json);
        return new static($data['id'], $data['name']);
    }

    public static function fromXml(string $xml): static {
        // Put your own logic here.
        $data = convert_xml_to_array($xml);
        $new = new static();
        $new->id = $data['id'];
        $new->name = $data['name'];
        return $new;
    }
}

$p1 = Product::fromBasicData(5, 'Widget');
$p2 = Product::fromJson($some_json_string);
$p3 = Product::fromXml($some_xml_string);
]]>
     </programlisting>
    </example>
    <para>
     The constructor may be made private or protected to prevent it from being called externally.
     If so, only a static method will be able to instantiate the class.  Because they are in the
     same class definition they have access to private methods, even if not of the same object
     instance.  The private constructor is optional and may or may not make sense depending on
     the use case..
    </para>
    <para>
     The three public static methods then demonstrate different ways of instantiating the object.
    </para>
    <simplelist>
     <member><code>fromBasicData()</code> takes the exact parameters that are needed, then creates the
      object by calling the constructor and returning the result.</member>
     <member><code>fromJson()</code> accepts a JSON string and does some pre-processing on it itself
     to convert it into the format desired by the constructor. It then returns the new object.</member>
     <member><code>fromXml()</code> accepts an XML string, preprocesses it, and then creates a bare
     object.  The constructor is still called, but as all of the parameters are optional the method
     skips them.  It then assigns values to the object properties directly before returning the result.</member>
    </simplelist>
    <para>
     In all three cases, the <code>static</code> keyword is translated into the name of the class the code is in.
     In this case, <code>Product</code>.
    </para>
   </sect3>
  </sect2>

 <sect2 xml:id="language.oop5.decon.destructor">
  <title>デストラクタ</title>
   <methodsynopsis xml:id="object.destruct">
   <type>void</type><methodname>__destruct</methodname>
   <void />
  </methodsynopsis>
  <para>
   PHP 5 では、C++ のような他のオブジェクト指向言語に似た概念のデストラクタが
   導入されました。デストラクタメソッドは、
   特定のオブジェクトを参照するリファレンスがひとつもなくなったときにコールされます。
   あるいは、スクリプトの終了時にも順不同でコールされます。
  </para>
  <example>
   <title>デストラクタの例</title>
   <programlisting role="php">
<![CDATA[
<?php

class MyDestructableClass 
{
    function __construct() {
        print "In constructor\n";
    }

    function __destruct() {
        print "Destroying " . __CLASS__ . "\n";
    }
}

$obj = new MyDestructableClass();
 
]]>
   </programlisting>
  </example>
  <para>
   コンストラクタと同様、親クラスのデストラクタがエンジンにより暗黙のうちに
   コールされるということはありません。親クラスのデストラクタを実行するには、
   デストラクタの中で明示的に <function>parent::__destruct</function>
   をコールする必要があります。
   また、コンストラクタと同様、子クラスでデストラクタを定義していない場合は
   親クラスのデストラクタを継承します。
  </para>
   <para>
    <function>exit</function>
    でスクリプトの実行を止めた場合にもデストラクタはコールされます。
    デストラクタの内部で <function>exit</function> をコールすると、
    それ以降のシャットダウンルーチンを実行しません。
   </para>
   <note>
    <para>
     スクリプトのシャットダウン時にデストラクタがコールされた場合は、
     HTTP ヘッダはすでに送信されています。スクリプトのシャットダウン時の作業ディレクトリは、
     SAPI によっては (たとえば Apache など) 異なります。
    </para>
   </note>
   <note>
    <para>
     デストラクタの中から (スクリプトの終了処理時に)
     例外をスローしようとすると、致命的なエラーを引き起こします。
    </para>
   </note>
 </sect2>

</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
