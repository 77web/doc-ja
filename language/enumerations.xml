<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 9fe810352095922a68ce2807745a9bc35c0afe1f Maintainer: mumumu Status: ready -->
 <chapter xml:id="language.enumerations" xmlns="http://docbook.org/ns/docbook">
  <title>列挙型(Enumerations)</title>
  <sect1 xml:id="language.enumerations.overview">
   <title>列挙型の概要</title>
   <?phpdoc print-version-for="enumerations"?>

   <para>
    列挙型(Enumerations) または "Enums" を使うと、
    開発者は取りうる値を限定した独自の型を定義できます。
    これによって、"不正な状態を表現できなくなる" ので、
    ドメインモデルを定義する時に特に役に立ちます。
   </para>

   <para>
    列挙型は、多くのプログラミング言語に備わっており、
    様々に異なる機能があります。
    PHP では、列挙型は特別な種類のオブジェクトです。
    列挙型そのものはクラスですし、そこで定義される case は全て、
    そのクラスのインスタンスです。
    これは、列挙型で定義される case は有効なオブジェクトであり、
    型チェックを含む、オブジェクトが使えるあらゆる場所で使えるということです。
   </para>

   <para>
    列挙型のもっとも有名な例は、組み込みの論理型(boolean) です。
    これは、有効な値 &true; と &false; を持つ列挙型です。
    列挙型によって、開発者は任意の値の一覧を、
    安定した形で定義できるようになります。
   </para>
  </sect1>
  <sect1 xml:id="language.enumerations.basics">
   <title>列挙型の基礎</title>

   <para>
    列挙型はクラスに似ていますし、
    クラスやインターフェイス、トレイトと名前空間を共有します。
    列挙型はオートローディングも可能です。
    列挙型は新しい型を定義しますが、
    固定の、限られた数の有効な値を持ちます。
   </para>


   <programlisting role="php">
<![CDATA[
<?php
enum Suit
{
    case Hearts;
    case Diamonds;
    case Clubs;
    case Spades;
}
?>
]]>
   </programlisting>

   <para>
    上記の宣言によって、新しい列挙型
    <literal>Suit</literal> が作られますが、
    これが持つ有効な値は4つだけです。
    <literal>Suit::Hearts</literal>、<literal>Suit::Diamonds</literal>、<literal>Suit::Clubs</literal>、そして <literal>Suit::Spades</literal> です。
    これらの有効な値のうち、ひとつだけを変数に代入できます。
    関数は列挙型に対する型チェックを行えますし、
    その場合は列挙型の値だけが渡せます。
   </para>

   <programlisting role="php">
<![CDATA[
<?php
function pick_a_card(Suit $suit) { ... }

$val = Suit::Diamonds;

// OK
pick_a_card($val);
// OK
pick_a_card(Suit::Clubs);
// TypeError: pick_a_card(): Argument #1 ($suit) must be of type Suit, string given
pick_a_card('Spades');
?>
]]>
   </programlisting>

   <para>
    列挙型は、0個以上の
    <literal>case</literal> を定義できます。
    <literal>case</literal> を定義する数に上限はありません。
    case が0個の列挙型も文法的には有効ですが、役に立ちません。
   </para>

   <para>
    デフォルトでは、case は本質的にスカラーの値に依存していません。
    つまり、<literal>Suit::Hearts</literal>
    は <literal>"0"</literal> に等しくないということです。
    むしろ、それぞれの case はその名前が付いたシングルトンオブジェクトです。
    以下のコードがそれを示しています:
   </para>

   <programlisting role="php">
<![CDATA[
<?php
$a = Suit::Spades;
$b = Suit::Spades;

$a === $b; // true

$a instanceof Suit;  // true
?>
]]>
   </programlisting>

   <para>
    このことは、列挙型の値は決して
    <literal>&lt;</literal> や <literal>&gt;</literal> 
    で比較できないことも意味しています。
    なぜなら、それらの比較をオブジェクトで行っても無意味だからです。
    列挙型の値を使ってこれらの比較を行っても、常に &false; を返します。
   </para>

   <para>
    関連するデータのない、こうしたタイプの case を、
    "Pure Case" と呼びます。
    Pure Case のみを含む列挙型を、"Pure Enum" と呼びます。
   </para>

   <para>
    全ての Pure Case は、その列挙型のインスタンスとして実装されています。
    列挙型は内部的にクラスとして表現されます。
   </para>

   <para>
    全ての case は読み取り専用のプロパティ
    <literal>name</literal> を持ちます。
    これは大文字小文字が区別される、case そのものの名前です。
    このプロパティは、デバッグ用途に役立つかも知れません。
   </para>

   <programlisting role="php">
<![CDATA[
<?php
print Suit::Spades->name;
// prints "Spades"
?>
]]>
   </programlisting>

  </sect1>

 <sect1 xml:id="language.enumerations.backed">
  <title>値に依存した列挙型(Backed Enum)</title>

  <para>
   デフォルトでは、列挙型はスカラー値の情報を持っていません。
   単なるシングルトンオブジェクトです。
   しかし、列挙型の case をデータベースや、
   類似のデータストアで読み書きする必要があるケースが多くあります。
   よって、ビルトインの (シリアライズ可能であることが自明な)
   スカラー値を持つ case があると、本質的に役に立ちます。
  </para>

  <para>
   列挙型にスカラー値を定義するには、以下のようにします:
  </para>

  <programlisting role="php">
<![CDATA[
<?php
enum Suit: string
{
    case Hearts = 'H';
    case Diamonds = 'D';
    case Clubs = 'C';
    case Spades = 'S';
}
?>
]]>
  </programlisting>

  <para>
   スカラー値を持つ case を、"Backed Case" と呼びます。
   なぜなら、オブジェクトよりもシンプルな値に依存して(Backed)いるからです。
   全ての case が Backed Case である列挙型を "Backed Enum" と呼びます。
   Backed Enum には Backed Case のみを含めることができます。
   Pure Enum には Pure Case だけを含めることができます。
  </para>

  <para>
   Backed Enum は、整数、または文字列の値を持つことができます。
   そして、単一の列挙型が一度に持つことの出来る型はひとつだけです
   (つまり、<literal>int|string</literal> のような union
   型はサポートしていないということです)。
   列挙型がスカラー情報を持つとマークすると、
   全ての case はユニークなスカラーの値を明示的に定義しなければいけません。
   自動生成されるスカラー値 (例: 整数のシーケンス値) は存在しません。
   Backed Enum の case の値は、全てユニークでなければいけません。
   つまり、ふたつの Backed Enum の case は、
   同じスカラー値を持ってはいけないということです。
   しかし、定数は case を参照していても構わないので、
   別名を作成することはできます。
   <link linkend="language.enumerations.constants">列挙型と定数</link>
   も参照下さい。
  </para>

  <para>
   スカラー値は、リテラルか、リテラルを表す式でなければいけません。
   定数や定数式はサポートしていません。
   つまり、<literal>1 + 1</literal> は許されますが、
   <literal>1 + SOME_CONST</literal> は許されません。
  </para>

  <para>
   Backed Enum の case は、追加の読み取り専用のプロパティ
   <literal>value</literal> を持っています。
   これは、Backed Enum の定義で指定された値です。
  </para>

  <programlisting role="php">
<![CDATA[
<?php
print Suit::Clubs->value;
// Prints "C"
?>
]]>
  </programlisting>

  <para>
   <literal>value</literal> プロパティを強制的に読み取り専用にするため、
   そのリファレンスを変数には代入できません。
   つまり、以下のようなコードはエラーになります:
  </para>

  <programlisting role="php">
<![CDATA[
<?php
$suit = Suit::Clubs;
$ref = &$suit->value;
// Error: Cannot acquire reference to property Suit::$value
?>
]]>
  </programlisting>

  <para>
   Backed Enum は内部的に
   <literal>BackedEnum</literal> インターフェイスを実装しています。
   このメソッドは、以下の2つのメソッドを公開しています:
  </para>

  <simplelist>
   <member>
    <literal>from(int|string): self</literal>
    スカラー値を受け取り、対応する Enum の case を返します。
    対応する case がない場合は、
    <classname>ValueError</classname>
    がスローされます。
    このメソッドは、入力のスカラー値が信頼でき、
    存在しない enum
    の値はアプリケーションを停止すべきエラーとみなせる場合に役立ちます。
   </member>
   <member>
    <literal>tryFrom(int|string): ?self</literal>
    スカラー値を受け取り、対応する Enum の case を返します。
    対応する case がない場合は、&null; を返します。
    このメソッドは、入力のスカラー値が信頼できない場合で、
    呼び出し側が独自のエラーハンドリングや、
    デフォルト値のロジックを実装したい場合に役立ちます。
   </member>
  </simplelist>

  <para>
   <literal>from()</literal> と <literal>tryFrom()</literal> 
   メソッドは、標準の 弱い/強い 型付けのルールに従います。
   弱い型付けのルールでは、整数または文字列を受け入れ、
   システムは値をそれに従って強制します。
   厳密な型付けモードの場合、文字列型の Backed Enum に整数値を渡す
   (またはその逆をする) と、<classname>TypeError</classname> が発生します。
   float についても、全ての場合に同じ型付けのルールに従います。
   それ以外の型については、どちらのモードでも TypeError が発生します。
  </para>

  <programlisting role="php">
<![CDATA[
<?php
$record = get_stuff_from_database($id);
print $record['suit'];

$suit =  Suit::from($record['suit']);
// Invalid data throws a ValueError: "X" is not a valid scalar value for enum "Suit"
print $suit->value;

$suit = Suit::tryFrom('A') ?? Suit::Spades;
// Invalid data returns null, so Suit::Spades is used instead.
print $suit->value;
?>
]]>
  </programlisting>

  <para>
   Backed Enum において、手動で <literal>from()</literal> や
   <literal>tryFrom()</literal> メソッドを定義すると、
   致命的なエラーが発生します。
  </para>

  </sect1>

 <sect1 xml:id="language.enumerations.methods">
  <title>列挙型とメソッド</title>

  <para>
   Enums (both Pure Enums and Backed Enums) may contain methods, and may implement interfaces.
   If an Enum implements an interface, then any type check for that interface will also accept
   all cases of that Enum.
  </para>

  <programlisting role="php">
<![CDATA[
<?php
interface Colorful
{
    public function color(): string;
}

enum Suit implements Colorful
{
    case Hearts;
    case Diamonds;
    case Clubs;
    case Spades;

    // Fulfills the interface contract.
    public function color(): string
    {
        return match($this) {
            Suit::Hearts, Suit::Diamonds => 'Red',
            Suit::Clubs, Suit::Spades => 'Black',
        };
    }

    // Not part of an interface; that's fine.
    public function shape(): string
    {
        return "Rectangle";
    }
}

function paint(Colorful $c) { ... }

paint(Suit::Clubs);  // Works

print Suit::Diamonds->shape(); // prints "rectangle"
?>
]]>
  </programlisting>

  <para>
   In this example, all four instances of <literal>Suit</literal> have two methods,
   <literal>color()</literal> and <literal>shape()</literal>.  As far as calling code
   and type checks are concerned, they behave exactly the same as any other object instance.
  </para>

  <para>
   On a Backed Enum, the interface declaration goes after the backing type declaration.
  </para>

  <programlisting role="php">
   <![CDATA[
<?php
interface Colorful
{
    public function color(): string;
}

enum Suit: string implements Colorful
{
    case Hearts = 'H';
    case Diamonds = 'D';
    case Clubs = 'C';
    case Spades = 'S';

    // Fulfills the interface contract.
    public function color(): string
    {
        return match($this) {
            Suit::Hearts, Suit::Diamonds => 'Red',
            Suit::Clubs, Suit::Spades => 'Black',
        };
    }
}
?>
]]>
  </programlisting>

  <para>
   Inside a method, the <literal>$this</literal> variable is defined and refers to the Case instance.
  </para>

  <para>
   Methods may be arbitrarily complex, but in practice will usually return a static value or
   <link linkend="control-structures.match">match</link> on <literal>$this</literal> to provide
   different results for different cases.
  </para>

  <para>
   Note that in this case it would be a better data modeling practice to also define a
   <literal>SuitColor</literal> Enum Type with values Red and Black and return that instead.
   However, that would complicate this example.
  </para>

  <para>
   The above hierarchy is logically similar to the following class structure
   (although this is not the actual code that runs):
  </para>

  <programlisting role="php">
<![CDATA[
<?php
interface Colorful
{
    public function color(): string;
}

final class Suit implements UnitEnum, Colorful
{
    public const Hearts = new self('Hearts');
    public const Diamonds = new self('Diamonds');
    public const Clubs = new self('Clubs');
    public const Spades = new self('Spades');

    private function __construct(public readonly string $name) {}

    public function color(): string
    {
        return match($this) {
            Suit::Hearts, Suit::Diamonds => 'Red',
            Suit::Clubs, Suit::Spades => 'Black',
        };
    }

    public function shape(): string
    {
        return "Rectangle";
    }

    public static function cases(): array
    {
        // See below.
    }
}
?>
]]>
  </programlisting>

  <para>
   Methods may be public, private, or protected, although in practice private and
   protected are equivalent as inheritance is not allowed.
  </para>

 </sect1>

 <sect1 xml:id="language.enumerations.static-methods">
  <title>列挙型と static メソッド</title>

  <para>
   Enumerations may also have static methods.  The use for static methods on the
   enumeration itself is primarily for alternative constructors.  E.g.:
  </para>

  <programlisting role="php">
<![CDATA[
<?php
enum Size
{
    case Small;
    case Medium;
    case Large;

    public static function fromLength(int $cm): static
    {
        return match(true) {
            $cm < 50 => static::Small,
            $cm < 100 => static::Medium,
            default => static::Large,
        };
    }
}
?>
]]>
  </programlisting>

  <para>
   Static methods may be public, private, or protected, although in practice private
   and protected are equivalent as inheritance is not allowed.
  </para>

 </sect1>

 <sect1 xml:id="language.enumerations.constants">
  <title>列挙型と定数</title>

  <para>
   Enumerations may include constants, which may be public, private, or protected,
   although in practice private and protected are equivalent as inheritance is not allowed.
  </para>

  <para>An enum constant may refer to an enum case:</para>

  <programlisting role="php">
<![CDATA[
<?php
enum Size
{
    case Small;
    case Medium;
    case Large;

    public const Huge = self::Large;
}
?>
]]>
  </programlisting>
 </sect1>

 <sect1 xml:id="language.enumerations.traits">
  <title>トレイト</title>

  <para>Enumerations may leverage traits, which will behave the same as on classes.
   The caveat is that traits <literal>use</literal>d in an enum must not contain properties.
   They may only include methods and static methods.  A trait with properties will
   result in a fatal error.
  </para>

  <programlisting role="php">
<![CDATA[
<?php
interface Colorful
{
    public function color(): string;
}

trait Rectangle
{
    public function shape(): string {
        return "Rectangle";
    }
}

enum Suit implements Colorful
{
    use Rectangle;

    case Hearts;
    case Diamonds;
    case Clubs;
    case Spades;

    public function color(): string
    {
        return match($this) {
            Suit::Hearts, Suit::Diamonds => 'Red',
            Suit::Clubs, Suit::Spades => 'Black',
        };
    }
}
?>
]]>
  </programlisting>
 </sect1>

 <sect1 xml:id="language.enumerations.expressions">
  <title>定数式における列挙型の値</title>

  <para>
   Because cases are represented as constants on the enum itself, they may be used as static
   values in most constant expressions: property defaults, static variable defaults, parameter
   defaults, global and class constant values. They may not be used in other enum case values, but
   normal constants may refer to an enum case.
  </para>

  <para>
   However, implicit magic method calls such as <classname>ArrayAccess</classname> on enums are not allowed in static
   or constant definitions as we cannot absolutely guarantee that the resulting value is deterministic
   or that the method invocation is free of side effects. Function calls, method calls, and
   property access continue to be invalid operations in constant expressions.
  </para>

  <programlisting role="php">
<![CDATA[
<?php
// This is an entirely legal Enum definition.
enum Direction implements ArrayAccess
{
    case Up;
    case Down;

    public function offsetGet($val) { ... }
    public function offsetExists($val) { ... }
    public function offsetSet($val) { throw new Exception(); }
    public functiond offsetUnset($val) { throw new Exception(); }
}

class Foo
{
    // This is allowed.
    const Bar = Direction::Down;

    // This is disallowed, as it may not be deterministic.
    const Bar = Direction::Up['short'];
    // Fatal error: Cannot use [] on enums in constant expression
}

// This is entirely legal, because it's not a constant expression.
$x = Direction::Up['short'];
?>
]]>
  </programlisting>
 </sect1>

 <sect1 xml:id="language.enumerations.object-differences">
  <title>オブジェクトとの違い</title>

  <para>
   Although Enums are built on classes and objects, they do not support all object-related functionality.
   In particular, Enum cases are forbidden from having state.
  </para>

  <simplelist>
   <member>Constructors and Destructors are forbidden.</member>
   <member>Inheritance is not supported. Enums may not extend or be extended.</member>
   <member>Static or object properties are not allowed.</member>
   <member>Cloning an Enum case is not supported, as cases must be singleton instances</member>
   <member><link linkend="language.oop5.magic">Magic methods</link>, except for those listed below, are disallowed.</member>
  </simplelist>

  <para>The following object functionality is available, and behaves just as it does on any other object:</para>

  <simplelist>
   <member>Public, private, and protected methods.</member>
   <member>Public, private, and protected static methods.</member>
   <member>Public, private, and protected constants.</member>
   <member>Enums may implement any number of interfaces.</member>
   <member>
    Enums and cases may have <link linkend="language.attributes">attributes</link> attached
    to them.  The <constant>TARGET_CLASS</constant> target
    filter includes Enums themselves.  The <constant>TARGET_CLASS_CONST</constant> target filter
    includes Enum Cases.
   </member>
   <member>
    <link linkend="object.call">__call</link>, <link linkend="object.callstatic">__callStatic</link>,
    and <link linkend="object.invoke">__invoke</link> magic methods
   </member>
   <member><constant>__CLASS__</constant> and <constant>__FUNCTION__</constant> constants behave as normal</member>
  </simplelist>

  <para>
   The <literal>::class</literal> magic constant on an Enum type evaluates to the type
   name including any namespace, exactly the same as an object.  The <literal>::class</literal>
   magic constant on a Case instance also evaluates to the Enum type, as it is an
   instance of that type.
  </para>

  <para>
   Additionally, enum cases may not be instantiated directly with <literal>new</literal>, nor with
   <literal>newInstanceWithoutConstructor</literal> in reflection.  Both will result in an error.
  </para>

  <programlisting role="php">
<![CDATA[
<?php
$clovers = new Suit();
// Error: Cannot instantiate enum Suit
$horseshoes = (new ReflectionClass(Suit::class))->newInstanceWithoutConstructor()
// Error: Cannot instantiate enum Suit
?>
]]>
  </programlisting>
 </sect1>

 <sect1 xml:id="language.enumerations.listing">
  <title>値のリスト</title>

  <para>
   Both Pure Enums and Backed Enums implement an internal interface named
   <literal>UnitEnum</literal>.  <literal>UnitEnum</literal> includes a static method
   <literal>cases()</literal>. <literal>cases()</literal> returns a packed array of
   all defined Cases in the order of declaration.
  </para>

  <programlisting role="php">
<![CDATA[
<?php
Suit::cases();
// Produces: [Suit::Hearts, Suit::Diamonds, Suit::Clubs, Suit:Spades]
?>
]]>
  </programlisting>

  <para>Manually defining a <literal>cases()</literal> method on an Enum will result in a fatal error.</para>
 </sect1>

 <sect1 xml:id="language.enumerations.serialization">
  <title>列挙型をシリアライズする</title>

  <para>
   Enumerations are serialized differently from objects.  Specifically, they have a new serialization code,
   <literal>"E"</literal>, that specifies the name of the enum case.  The deserialization routine is then
   able to use that to set a variable to the existing singleton value.  That ensures that:
  </para>

  <programlisting role="php">
<![CDATA[
<?php
Suit::Hearts === unserialize(serialize(Suit::Hearts));

print serialize(Suit::Hearts);
// E:11:"Suit:Hearts";
?>
]]>
  </programlisting>

  <para>
   On deserialization, if an enum and case cannot be found to match a serialized
   value a warning will be issued and <literal>false</literal> returned.</para>

  <para>
   If a Pure Enum is serialized to JSON, an error will be thrown.  If a Backed Enum
   is serialized to JSON, it will be represented by its value scalar only, in the
   appropriate type.  The behavior of both may be overridden by implementing
   <classname>JsonSerializable</classname>.
  </para>

  <para>For <function>print_r</function>, the output of an enum case is slightly different
   from objects to minimize confusion.
  </para>

  <programlisting role="php">
<![CDATA[
<?php
enum Foo {
    case Bar;
}

enum Baz: int {
    case Beep = 5;
}

print_r(Foo::Bar);
print_r(Baz::Beep);

/* Produces

Foo Enum (
    [name] => Bar
)
Baz Enum:int {
    [name] => Beep
    [value] => 5
}
*/
?>
]]>
  </programlisting>
 </sect1>

 <sect1 xml:id="language.enumerations.examples">
  &reftitle.examples;

  <para>
   <example>
    <title>Basic limited values</title>
    <programlisting role="php">
<![CDATA[
<?php
enum SortOrder
{
    case ASC;
    case DESC;
}

function query($fields, $filter, SortOrder $order = SortOrder::ASC) { ... }
?>
]]>
    </programlisting>
    <para>
     The <literal>query()</literal> function can now proceed safe in the knowledge that
     <literal>$order</literal> is guaranteed to be either <literal>SortOrder::ASC</literal>
     or <literal>SortOrder::DESC</literal>.  Any other value would have resulted in a
     <classname>TypeError</classname>, so no further error checking or testing is needed.
    </para>
   </example>
  </para>

  <para>

   <example>
    <title>Advanced exclusive values</title>

    <programlisting role="php">
<![CDATA[
<?php
enum UserStatus: string
{
    case Pending = 'P';
    case Active = 'A';
    case Suspended = 'S';
    case CanceledByUser = 'C';

    public function label(): string
    {
        return match($this) {
            static::Pending => 'Pending',
            static::Active => 'Active',
            static::Suspended => 'Suspended',
            static::CanceledByUser => 'Canceled by user',
        };
    }
}
?>
]]>
    </programlisting>

    <para>
     In this example, a user's status may be one of, and exclusively, <literal>UserStatus::Pending</literal>,
     <literal>UserStatus::Active</literal>, <literal>UserStatus::Suspended</literal>, or
     <literal>UserStatus::CanceledByUser</literal>.  A function can type a parameter against
     <literal>UserStatus</literal> and then only accept those four values, period.
    </para>

    <para>
     All four values have a <literal>label()</literal> method, which returns a human-readable string.
     That string is independent of the "machine name" scalar equivalent string, which can be used in,
     for example, a database field or an HTML select box.
    </para>

    <programlisting role="php">
<![CDATA[
<?php
foreach (UserStatus::cases() as $case) {
    printf('<option value="%s">%s</option>\n', $case->value, $case->label());
}
?>
]]>
    </programlisting>
   </example>
  </para>

 </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
